<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module contains [`Trace`]s consisting of several [`Step`]s, of which each has either an [`OutputAction`] or [`InputAction`]. This is a declarative way of modeling communication between [`Agent`]s. The [`TraceContext`] holds data, also known as [`VariableData`], which is created by [`Agent`]s during the concrete execution of the Trace. It also holds the [`Agent`]s with the references to concrete PUT."><meta name="keywords" content="rust, rustlang, rust-lang, trace"><title>tlspuffin::trace - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><script defer src="../../main.js"></script>
    <noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../tlspuffin/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../tlspuffin/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Module trace</a></h2><div class="sidebar-elems"><section><div class="block"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></div></section><div id="sidebar-vars" data-name="trace" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../tlspuffin/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Module <a href="../index.html">tlspuffin</a>::<wbr><a class="mod" href="#">trace</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../src/tlspuffin/trace.rs.html#1-673">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module contains <a href="struct.Trace.html" title="Trace"><code>Trace</code></a>s consisting of several <a href="struct.Step.html" title="Step"><code>Step</code></a>s, of which each has either an
<a href="struct.OutputAction.html" title="OutputAction"><code>OutputAction</code></a> or <a href="struct.InputAction.html" title="InputAction"><code>InputAction</code></a>. This is a declarative way of modeling communication between
<a href="../agent/struct.Agent.html" title="Agent"><code>Agent</code></a>s. The <a href="struct.TraceContext.html" title="TraceContext"><code>TraceContext</code></a> holds data, also known as <a href="../variable_data/trait.VariableData.html" title="VariableData"><code>VariableData</code></a>, which is created by
<a href="../agent/struct.Agent.html" title="Agent"><code>Agent</code></a>s during the concrete execution of the Trace. It also holds the <a href="../agent/struct.Agent.html" title="Agent"><code>Agent</code></a>s with
the references to concrete PUT.</p>
<h2 id="example"><a href="#example">Example</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">tlspuffin::agent</span>::{<span class="ident">AgentName</span>, <span class="ident">AgentDescriptor</span>, <span class="ident">TLSVersion</span>::<span class="kw-2">*</span>};
<span class="kw">use</span> <span class="ident">tlspuffin::trace</span>::{<span class="ident">Step</span>, <span class="ident">TraceContext</span>, <span class="ident">Trace</span>, <span class="ident">Action</span>, <span class="ident">InputAction</span>, <span class="ident">OutputAction</span>, <span class="ident">Query</span>, <span class="ident">TlsMessageType</span>};
<span class="kw">use</span> <span class="ident">tlspuffin::term</span>::{<span class="ident">Term</span>, <span class="ident">signature::Signature</span>};
<span class="kw">use</span> <span class="ident">tlspuffin::tls::fn_impl::fn_client_hello</span>;
<span class="kw">use</span> <span class="ident">rustls</span>::{<span class="ident">ProtocolVersion</span>, <span class="ident">CipherSuite</span>};
<span class="kw">use</span> <span class="ident">rustls::msgs::handshake</span>::{<span class="ident">SessionID</span>, <span class="ident">Random</span>, <span class="ident">ClientExtension</span>};
<span class="kw">use</span> <span class="ident">rustls::msgs::enums</span>::{<span class="ident">Compression</span>, <span class="ident">HandshakeType</span>};
<span class="kw">use</span> <span class="ident">tlspuffin::concretize::PUTType</span>;

<span class="kw">let</span> <span class="ident">client</span>: <span class="ident">AgentName</span> <span class="op">=</span> <span class="ident">AgentName::first</span>();
<span class="kw">let</span> <span class="ident">server</span>: <span class="ident">AgentName</span> <span class="op">=</span> <span class="ident">client</span>.<span class="ident">next</span>();

<span class="kw">let</span> <span class="ident">query</span> <span class="op">=</span> <span class="ident">Query</span> {
    <span class="ident">agent_name</span>: <span class="ident">client</span>,
    <span class="ident">tls_message_type</span>: <span class="prelude-val">Some</span>(<span class="ident">TlsMessageType::Handshake</span>(<span class="prelude-val">Some</span>(<span class="ident">HandshakeType::ClientHello</span>))),
    <span class="ident">counter</span>: <span class="number">0</span>
};
<span class="kw">let</span> <span class="ident">trace</span> <span class="op">=</span> <span class="ident">Trace</span> {
    <span class="ident">prior_traces</span>: <span class="macro">vec!</span>[],
    <span class="ident">descriptors</span>: <span class="macro">vec!</span>[
        <span class="ident">AgentDescriptor::new_client</span>(<span class="ident">client</span>, <span class="ident">V1_3</span>, <span class="ident">PUTType::OpenSSL</span>),
        <span class="ident">AgentDescriptor::new_server</span>(<span class="ident">server</span>, <span class="ident">V1_3</span>, <span class="ident">PUTType::OpenSSL</span>),
    ],
    <span class="ident">steps</span>: <span class="macro">vec!</span>[
            <span class="ident">Step</span> { <span class="ident">agent</span>: <span class="ident">client</span>, <span class="ident">action</span>: <span class="ident">Action::Output</span>(<span class="ident">OutputAction</span> { }) },
            <span class="comment">// Client: Hello Client -&gt; Server</span>
            <span class="ident">Step</span> {
                <span class="ident">agent</span>: <span class="ident">server</span>,
                <span class="ident">action</span>: <span class="ident">Action::Input</span>(<span class="ident">InputAction</span> {
                    <span class="ident">recipe</span>: <span class="ident">Term::Application</span>(
                        <span class="ident">Signature::new_function</span>(<span class="kw-2">&amp;</span><span class="ident">fn_client_hello</span>),
                        <span class="macro">vec!</span>[
                            <span class="ident">Term::Variable</span>(<span class="ident">Signature::new_var</span>::<span class="op">&lt;</span><span class="ident">ProtocolVersion</span><span class="op">&gt;</span>(<span class="ident">query</span>)),
                            <span class="ident">Term::Variable</span>(<span class="ident">Signature::new_var</span>::<span class="op">&lt;</span><span class="ident">Random</span><span class="op">&gt;</span>(<span class="ident">query</span>)),
                            <span class="ident">Term::Variable</span>(<span class="ident">Signature::new_var</span>::<span class="op">&lt;</span><span class="ident">SessionID</span><span class="op">&gt;</span>(<span class="ident">query</span>)),
                            <span class="ident">Term::Variable</span>(<span class="ident">Signature::new_var</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">CipherSuite</span><span class="op">&gt;</span><span class="op">&gt;</span>(<span class="ident">query</span>)),
                            <span class="ident">Term::Variable</span>(<span class="ident">Signature::new_var</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Compression</span><span class="op">&gt;</span><span class="op">&gt;</span>(<span class="ident">query</span>)),
                            <span class="ident">Term::Variable</span>(<span class="ident">Signature::new_var</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">ClientExtension</span><span class="op">&gt;</span><span class="op">&gt;</span>(<span class="ident">query</span>)),
                        ],
                    ),
                }),
            },
    <span class="comment">// further steps here</span>
    ]
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ctx</span> <span class="op">=</span> <span class="ident">TraceContext::new</span>();
<span class="ident">trace</span>.<span class="ident">execute</span>(<span class="kw-2">&amp;mut</span> <span class="ident">ctx</span>).<span class="ident">unwrap</span>();</code></pre></div>
<h4 id="serializability-of-traces"><a href="#serializability-of-traces">Serializability of Traces</a></h4>
<p>Each trace is serializable to JSON or even binary data. This helps at reproducing discovered
security vulnerabilities during fuzzing. If a trace triggers a security vulnerability we can
store it on disk and replay it when investigating the case.
As traces depend on concrete implementations as discussed in the next section we need to link
serialized data like strings or numerical IDs to functions implemented in Rust.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.AgentClaimer.html" title="tlspuffin::trace::AgentClaimer struct">AgentClaimer</a></div><div class="item-right docblock-short"><p>Claimer which gets claims from a VecClaimer but filters by <a href="../agent/struct.AgentName.html" title="AgentName"><code>AgentName</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.InputAction.html" title="tlspuffin::trace::InputAction struct">InputAction</a></div><div class="item-right docblock-short"><p>The <a href="struct.InputAction.html" title="InputAction"><code>InputAction</code></a> evaluates the recipe term and injects the newly produced message
into the <em>inbound channel</em> of the <a href="../agent/struct.Agent.html" title="Agent"><code>Agent</code></a> referenced through the corresponding <a href="struct.Step.html" title="Step"><code>Step</code></a>s
by calling <code>add_to_inbound(...)</code> and then drives the state machine forward.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Knowledge.html" title="tlspuffin::trace::Knowledge struct">Knowledge</a></div><div class="item-right docblock-short"><p><a href="struct.Knowledge.html" title="Knowledge">Knowledge</a> describes an atomic piece of knowledge inferred
by the <a href="../variable_data/fn.extract_knowledge.html" title="crate::variable_data::extract_knowledge"><code>crate::variable_data::extract_knowledge</code></a> function
<a href="struct.Knowledge.html" title="Knowledge">Knowledge</a> is made of the data, the agent that produced the output, the TLS message type and the internal type.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.OutputAction.html" title="tlspuffin::trace::OutputAction struct">OutputAction</a></div><div class="item-right docblock-short"><p>The <a href="struct.OutputAction.html" title="OutputAction"><code>OutputAction</code></a> first forwards the state machine and then extracts knowledge from the
TLS messages produced by the underlying stream by calling  <code>take_message_from_outbound(...)</code>.
An output action is automatically called after each input step.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Query.html" title="tlspuffin::trace::Query struct">Query</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Step.html" title="tlspuffin::trace::Step struct">Step</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Trace.html" title="tlspuffin::trace::Trace struct">Trace</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TraceContext.html" title="tlspuffin::trace::TraceContext struct">TraceContext</a></div><div class="item-right docblock-short"><p>The <a href="struct.TraceContext.html" title="TraceContext"><code>TraceContext</code></a> contains a list of <a href="../variable_data/trait.VariableData.html" title="VariableData"><code>VariableData</code></a>, which is known as the knowledge
of the attacker. <a href="../variable_data/trait.VariableData.html" title="VariableData"><code>VariableData</code></a> can contain data of various types like for example
client and server extensions, cipher suits or session ID It also holds the concrete
references to the <a href="../agent/struct.Agent.html" title="Agent"><code>Agent</code></a>s and the underlying streams, which contain the messages
which have need exchanged and are not yet processed by an output step.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.VecClaimer.html" title="tlspuffin::trace::VecClaimer struct">VecClaimer</a></div><div class="item-right docblock-short"></div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Action.html" title="tlspuffin::trace::Action enum">Action</a></div><div class="item-right docblock-short"><p>There are two action types <a href="struct.OutputAction.html" title="OutputAction"><code>OutputAction</code></a> and <a href="struct.InputAction.html" title="InputAction"><code>InputAction</code></a> differ.
Both actions drive the internal state machine of an <a href="../agent/struct.Agent.html" title="Agent"><code>Agent</code></a> forward by calling <code>next_state()</code>.
The <a href="struct.OutputAction.html" title="OutputAction"><code>OutputAction</code></a> first forwards the state machine and then extracts knowledge from the
TLS messages produced by the underlying stream by calling  <code>take_message_from_outbound(...)</code>.
The <a href="struct.InputAction.html" title="InputAction"><code>InputAction</code></a> evaluates the recipe term and injects the newly produced message
into the <em>inbound channel</em> of the <a href="../agent/struct.Agent.html" title="Agent"><code>Agent</code></a> referenced through the corresponding <a href="struct.Step.html" title="Step"><code>Step</code></a>s
by calling <code>add_to_inbound(...)</code> and then drives the state machine forward.
Therefore, the difference is that one step <em>increases</em> the knowledge of the attacker,
whereas the other action <em>uses</em> the available knowledge.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.TlsMessageType.html" title="tlspuffin::trace::TlsMessageType enum">TlsMessageType</a></div><div class="item-right docblock-short"><p>[MessageType] contains TLS-related typing information, this is to be distinguished from the *.typ fields
It uses [rustls::msgs::enums::{ContentType,HandshakeType}].</p>
</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.QueryMatcher.html" title="tlspuffin::trace::QueryMatcher trait">QueryMatcher</a></div><div class="item-right docblock-short"></div></div></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="tlspuffin" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.60.0 (7737e0b5c 2022-04-04)" ></div>
</body></html>
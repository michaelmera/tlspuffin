use std::env;
use std::path::PathBuf;

pub fn build_vendor(vendor_dir: PathBuf, version: &str) -> PathBuf {
    let src_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));

    // TODO add features to the vendor path
    //
    //     The vendor library need to be rebuilt each time a cargo PUT feature
    //     changes and coexist with other libs that have a different set of
    //     features. To distinguish between the different variants, we should
    //     had a path component that is unique to the combination of features
    //     passed to cargo.
    //
    //     They are mainly two ways to solve the problem: create a hashed
    //     version of the features set or simply concatenate the features.  The
    //     advantage of keeping the feature names is the improved
    //     discoverability for the user, but depending on the number of features
    //     we expose through cargo this might result is very long paths.
    //
    //     If we choose to use a hash for the features, it would make sense to
    //     add a file containing the set of features inside the install prefix
    //     directory, so that the user can still figure out against which
    //     configuration he's building the PUT.
    //
    let vendor_prefix = vendor_dir
        .join(env::var("TARGET").unwrap())
        .join("openssl")
        .join(version);

    cmake::Config::new(src_dir.join("vendor/openssl"))
        .always_configure(false)
        .define("OPENSSL_GIT_REF", version)
        .out_dir(&vendor_prefix)
        .build_target("openssl")
        .build();

    vendor_prefix
}

pub fn build_libs(vendor_prefix: PathBuf) {
    let src_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let inc_dir = out_dir.join("include");

    cmake::Config::new(src_dir)
        .define("OPENSSL_DIR", vendor_prefix)
        .define("TLSPUFFIN_INCDIR", inc_dir)
        .build();

    println!(
        "cargo:rustc-link-search=native={}",
        out_dir.to_str().unwrap()
    );
    println!("cargo:rustc-link-lib=static=puts-libs");
}

fn build_bindings() {
    let out_dir = env::var("OUT_DIR").unwrap();

    let bindings_path = PathBuf::from(&out_dir).join("bindings.rs");
    bindgen::Builder::default()
        .header("src/put.h")
        .no_copy("^AGENT_DESCRIPTOR$")
        .parse_callbacks(Box::new(bindgen::CargoCallbacks))
        .generate()
        .expect("Unable to generate bindings for cput")
        .write_to_file(&bindings_path)
        .expect("Couldn't write bindings!");

    println!(
        "cargo:rustc-env=RUST_BINDINGS_FILE={}",
        bindings_path.to_string_lossy()
    );

    let dst_dir = PathBuf::from(out_dir);
    let inc_dir = dst_dir.join("include/tlspuffin");

    std::fs::create_dir_all(&inc_dir).unwrap();

    // NOTE cc automatically emits link flags for cargo
    //
    //     Alongside the rust bindings file generated by bindgen, this build
    //     script creates the `puts-sys-c` library containing the C-implemented
    //     part of the `puts-sys` library. This is specified through the `links`
    //     field in Cargo.toml.
    //
    //     It might be confusing that we never actually tell cargo where to find
    //     this native library. This is because the `cc` crate automatically
    //     emits these flags.
    //
    //     If we ever replace `cc`, we will need to manually emit the cargo
    //     metadata `cargo:rustc-link-lib` and `cargo:rustc-link-search`.
    cc::Build::new()
        .include(&inc_dir)
        .file("src/put.c")
        .compile("puts-sys-c");

    std::fs::copy("src/put.h", inc_dir.join("put.h")).unwrap();

    println!("cargo:root={}", dst_dir.to_str().unwrap());
    println!("cargo:include={}/include", dst_dir.to_str().unwrap());
}

pub fn main() {
    println!("cargo:rerun-if-env-changed=VENDOR_DIR");
    println!("cargo:rerun-if-env-changed=OPENSSL_DIR");
    println!("cargo:rerun-if-env-changed=OPENSSL_VERSION");
    println!("cargo:rerun-if-changed={}", env!("CARGO_MANIFEST_DIR"));

    build_bindings();

    fn openssl_prefix() -> PathBuf {
        if env::var("OPENSSL_DIR").is_ok() {
            return PathBuf::from(env::var("OPENSSL_DIR").unwrap());
        }

        if env::var("OPENSSL_VERSION").is_ok() {
            let version = env::var("OPENSSL_VERSION").unwrap();
            let vendor_dir = PathBuf::from(
                env::var("VENDOR_DIR")
                    .unwrap_or(concat!(env!("CARGO_MANIFEST_DIR"), "/../vendor").to_string()),
            );

            return build_vendor(vendor_dir, &version);
        }

        panic!("native dependency not found: need either OPENSSL_DIR or OPENSSL_VERSION environment variable");
    }

    build_libs(openssl_prefix());
}

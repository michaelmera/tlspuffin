use std::env;
use std::path::PathBuf;

pub fn build_libs_with_openssl(openssl_root: PathBuf) {
    let src_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

    cmake::Config::new(src_dir)
        .profile("Debug")
        .define("BUILD_SHARED_LIBS", "OFF")
        .define("WITH_OPENSSL", openssl_root)
        .build();

    println!(
        "cargo:rustc-link-search=native={}",
        out_dir.to_str().unwrap()
    );
    println!("cargo:rustc-link-lib=static=bundle-puts");
}

pub fn build_libs(vendor_dir: PathBuf) {
    let src_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

    cmake::Config::new(src_dir)
        .define("VENDOR_DIR", vendor_dir)
        .build();

    println!(
        "cargo:rustc-link-search=native={}",
        out_dir.to_str().unwrap()
    );
    println!("cargo:rustc-link-lib=static=bundle-puts");
}

fn build_bindings() {
    let out_dir = env::var("OUT_DIR").unwrap();

    let bindings_path = PathBuf::from(&out_dir).join("bindings.rs");
    bindgen::Builder::default()
        .header("include/tlspuffin/put.h")
        .no_copy("^AGENT_DESCRIPTOR$")
        .parse_callbacks(Box::new(bindgen::CargoCallbacks))
        .generate()
        .expect("Unable to generate bindings for cput")
        .write_to_file(&bindings_path)
        .expect("Couldn't write bindings!");

    println!(
        "cargo:rustc-env=RUST_BINDINGS_FILE={}",
        bindings_path.to_string_lossy()
    );

    let src_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let inc_dir = src_dir.join("include");
    let dst_dir = PathBuf::from(out_dir);

    std::fs::create_dir_all(&inc_dir).unwrap();

    // NOTE cc automatically emits link flags for cargo
    //
    //     Alongside the rust bindings file generated by bindgen, this build
    //     script creates the `puts-sys-c` library containing the C-implemented
    //     part of the `puts-sys` library. This is specified through the `links`
    //     field in Cargo.toml.
    //
    //     It might be confusing that we never actually tell cargo where to find
    //     this native library. This is because the `cc` crate automatically
    //     emits these flags.
    //
    //     If we ever replace `cc`, we will need to manually emit the cargo
    //     metadata `cargo:rustc-link-lib` and `cargo:rustc-link-search`.
    cc::Build::new()
        .include(&inc_dir)
        .file("src/put.c")
        .compile("puts-sys-c");

    println!("cargo:root={}", dst_dir.to_str().unwrap());
    println!("cargo:include={}", inc_dir.to_str().unwrap());
}

pub fn main() {
    println!("cargo:rerun-if-env-changed=WITH_OPENSSL");
    println!("cargo:rerun-if-env-changed=VENDOR_DIR");
    println!("cargo:rerun-if-changed={}", env!("CARGO_MANIFEST_DIR"));

    build_bindings();

    let openssl_root = PathBuf::from(
        env::var("WITH_OPENSSL").expect("missing mandatory env variable WITH_OPENSSL"),
    );
    build_libs_with_openssl(openssl_root);

    // FIXME should drop support for WITH_OPENSSL
    //
    //     This will only be possible when we support linking tlspuffin against
    //     several C PUTs. In the meantime, we let cargo users specify the path
    //     to an OpenSSL install directory in the env variable WITH_OPENSSL.
    //
    //     In replacement, the following commented code look for a VENDOR_DIR
    //     and link tlspuffin with every C PUTs found inside.

    // let vendor_dir = PathBuf::from(
    //     env::var("VENDOR_DIR")
    //         .unwrap_or(concat!(env!("CARGO_MANIFEST_DIR"), "/../vendor").to_string()),
    // );
    // build_libs(vendor_dir);
}

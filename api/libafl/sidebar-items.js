window.SIDEBAR_ITEMS = {"attr":[["ctor","Marks a function or static variable as a library/executable constructor. This uses OS-specific linker sections to call a specific function at load time."]],"enum":[["Error","Main error struct for `LibAFL`"]],"externcrate":[["alloc",""]],"macro":[["create_anymap_for_trait","Create `AnyMap` and `NamedAnyMap` for a given trait"],["create_serde_registry_for_trait","Creates the [`serde`] registry for serialization and deserialization of [`SerdeAny`]. Each element needs to be registered so that it can be deserialized."],["feedback_and","Variadic macro to create a chain of `AndFeedback`"],["feedback_and_fast","Variadic macro to create a chain of (fast) `AndFeedback`"],["feedback_not","Variadic macro to create a [`NotFeedback`]"],["feedback_or","Variadic macro to create a chain of `OrFeedback`"],["feedback_or_fast","Combines multiple feedbacks with an `OR` operation, not executing feedbacks after the first positive result"],["impl_asany","Implement `AsAny` for a type"],["impl_serdeany","Implement a [`SerdeAny`], registering it in the [`RegistryBuilder`] when on std"],["mark_feature_time","Mark the elapsed time for the given feature"],["mark_feedback_time","Mark the elapsed time for the given feature"],["register_at_startup","Register a `SerdeAny` type in the [`RegistryBuilder`]"],["start_timer","Start the timer"],["tuple_for_each","Iterate over a tuple, executing the given `expr` for each element."],["tuple_for_each_mut","Iterate over a tuple, executing the given `expr` for each element, granting mut access."]],"mod":[["bolts","Bolts are no conceptual fuzzing elements, but they keep libafl-based fuzzers together."],["corpus","Corpuses contain the testcases, either in memory, on disk, or somewhere else."],["events","Eventmanager manages all events that go to other instances of the fuzzer."],["executors","Executors take input, and run it in the target."],["feedbacks","The feedbacks reduce observer state after each run to a single `is_interesting`-value. If a testcase is interesting, it may be added to a Corpus."],["fuzzer","The `Fuzzer` is the main struct for a fuzz campaign."],["generators","Generators may generate bytes or, in general, data, for inputs."],["inputs","Inputs are the actual contents sent to a target for each exeuction."],["monitors","Keep stats, and display them to the user. Usually used in a broker, or main node, of some sort."],["mutators","Mutators mutate input during fuzzing."],["observers","Observers give insights about runs of a target, such as coverage, timing, stack depth, and more."],["schedulers","Schedule the access to the Corpus."],["stages","A [`Stage`] is a technique used during fuzzing, working on one [`crate::corpus::Corpus`] entry, and potentially altering it or creating new entries. A well-known [`Stage`], for example, is the mutational stage, running multiple [`crate::mutators::Mutator`]s against a [`crate::corpus::Testcase`], potentially storing new ones, according to [`crate::feedbacks::Feedback`]. Other stages may enrich [`crate::corpus::Testcase`]s with metadata."],["state","The fuzzer, and state are the core pieces of every good fuzzer"]],"struct":[["ErrorBacktrace","Empty struct to use when `errors_backtrace` is disabled"]]};
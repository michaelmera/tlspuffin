window.SIDEBAR_ITEMS = {"mod":[["calibrate","The calibration stage. The fuzzer measures the average exec time and the bitmap size."],["concolic","This module contains the `concolic` stages, which can trace a target using symbolic execution and use the results for fuzzer input and mutations."],["generalization","The tracing stage can trace the target and enrich a testcase with metadata, for example for `CmpLog`."],["mutational","Mutational stage is the normal fuzzing stage. For the current input, it will perform a range of random mutations, and then run them in the executor."],["owned","A dynamic collection of owned Stages"],["power","The power schedules. This stage should be invoked after the calibration stage."],["push","While normal stages call the executor over and over again, push stages turn this concept upside down: A push stage instead returns an iterator that generates a new result for each time it gets called. With the new testcase, you will have to take care about testcase execution, manually. The push stage relies on internal muttability of the supplied `Observers`."],["sync","For the current input, it will perform a range of random mutations, and then run them in the executor."],["tracing","The tracing stage can trace the target and enrich a testcase with metadata, for example for `CmpLog`."]],"struct":[["ClosureStage","A [`Stage`] that will call a closure"],["PushStageAdapter","Allows us to use a [`push::PushStage`] as a normal [`Stage`]"]],"trait":[["Stage","A stage is one step in the fuzzing process. Multiple stages will be scheduled one by one for each input."],["StagesTuple","A tuple holding all `Stages` used for fuzzing."]]};
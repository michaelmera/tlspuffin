window.SIDEBAR_ITEMS = {"enum":[["BrokerEventResult","Indicate if an event worked or not"],["CustomBufEventResult","The result of a custom buf handler added using [`HasCustomBufHandlers::add_custom_buf_handler`]"],["Event","Events sent around in the library"],["EventConfig","Distinguish a fuzzer by its config"],["LogSeverity","The log event severity"]],"mod":[["llmp","LLMP-backed event manager for scalable multi-processed fuzzing"],["simple","A very simple event manager, that just supports log outputs, but no multiprocessing"]],"struct":[["EventManagerId","A per-fuzzer unique `ID`, usually starting with `0` and increasing by `1` in multiprocessed `EventManager`s, such as [`self::llmp::LlmpEventManager`]."],["NopEventManager","An eventmgr for tests, and as placeholder if you really don’t need an event manager."]],"trait":[["EventFirer","[`EventFirer`] fire an event."],["EventManager","[`EventManager`] is the main communications hub. For the “normal” multi-processed mode, you may want to look into [`LlmpRestartingEventManager`]"],["EventProcessor","[`EventProcessor`] process all the incoming messages"],["EventRestarter","Restartable trait"],["HasCustomBufHandlers","Supports custom buf handlers to handle `CustomBuf` events."],["HasEventManagerId","The id of this [`EventManager`]. For multi processed [`EventManager`]s, each connected client should have a unique ids."],["ProgressReporter","[`ProgressReporter`] report progress to the broker."]]};